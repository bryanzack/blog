---
layout: post
title: "JWTF"
date: 2025-05-18
---

#### About

This challenge requires users to abuse string comparison checks against JWTs to retrieve the flag.



#### The Challenge

The challenge description is as follows:

```
Unfortunately one of our JWTs was compromised by attackers, so we created a JWT Revocation List to ensure they can't use it anymore.
```

We are given the server-side code for the website in `server.js`:

```python
# imports
from flask import Flask, request, redirect, make_response, jsonify
import jwt, os


# initialize flask
app = Flask(__name__)
FLAG = open('flag.txt', 'r').read()
APP_SECRET = os.urandom(32).hex()
ADMIN_SECRET = os.urandom(32).hex()
print(f'ADMIN_SECRET: {ADMIN_SECRET}')


# JRL - JWT Revocation List
jrl = [
    jwt.encode({"admin": True, "uid": '1337'}, APP_SECRET, algorithm="HS256")
]


# main
@app.route('/', methods=['GET'])
def main():
    resp = make_response('Hello World!')
    resp.set_cookie('session', jwt.encode({"admin": False}, APP_SECRET, algorithm="HS256"))
    return resp

# get admin cookie if you know the secret
@app.route('/get_admin_cookie', methods=['GET'])
def get_admin_cookie():
    secret = request.args.get('adminsecret', None)
    uid = request.args.get('uid', None)

    if secret is None or uid is None or uid == '1337':
        return redirect('/')

    if secret == ADMIN_SECRET:
        resp = make_response('Cookie has been set.')
        resp.set_cookie('session', jwt.encode({"admin": True, "uid": uid}, APP_SECRET, algorithm="HS256"))
        return resp

# get flag if you are an admin
@app.route('/flag', methods=['GET'])
def flag():
    session = request.cookies.get('session', None).strip().replace('=','')

    if session is None:
        return redirect('/')
    
    # check if the session is in the JRL
    if session in jrl:
        return redirect('/')

    try:
        payload = jwt.decode(session, APP_SECRET, algorithms=["HS256"])
        if payload['admin'] == True:
            return FLAG
        else:
            return redirect('/')
    except:
        return redirect('/')

# retrieve the JRL
@app.route('/jrl', methods=['GET'])
def jrl_endpoint():
    return jsonify(jrl)


if __name__ == "__main__":
    app.run(host='0.0.0.0', port=1337, threaded=True)
```



In short, a valid JWT is accessible to use through the `/jrl` endpoint, but if we use that same JWT it gets rejected because the server-side code performs a string comparison against our JWT and the JWT that resides in the `jrl` list seen above. I only found this out after going down the `/get_admin_cookie` rabbit hole for a bit.



#### Base64 Inconsistency

After a bit of research we can find that the fact that the JWT in the java revocation list and our own JWT are treated as strings and then compared can be abused with how JWT libraries interpret tokens. JWTs are encoded with Base64, but there are different flavors of Base64. In this case there is standard `Base64` and `Base64url`. The differences can be seen below:

| Aspect            | Standard Base64            | Base64url                               |
| ----------------- | -------------------------- | --------------------------------------- |
| Character Set     | A-Z, a-z, 0-9, `+` and `/` | A-Z, a-z, 0-9, `-` and `_`              |
| Last 2 Characters | `+` and `/`                | `-` and `_`                             |
| Padding           | Uses = for padding         | Often omits padding, but can include it |
| URL Safety        | Not URL-safe               | URL-safe                                |



Through research, we find that two JWT payloads can can be decoded to the **same object** while not being equal when compared as strings. In this challenge, the JWT library used will accept both `Standard Base64` and `Base64url` as valid JWTs. The JWT found in the `jrl` can clearly be seen as using `Base64url`: 

![base64_url](https://i.imgur.com/p8woc24.png)

If we were to set that as our JWT and hit the `/flag` endpoint, we would be redirected to `/`. But if we take that same JWT and replace the `-` with `+` and `_` with `/`, we see if it will accept the `Standard Base64` version of the `jrl` JWT that will decode to the same exact payload, maintaining the integrity provided by being signed by the `APP_SECRET`, while being string **inequal** to the `Base64url` JWT stored in `jrl`:

#### Flag

![flag](https://i.imgur.com/0h1esRy.png)